{"ast":null,"code":"import { debounce, get } from 'lodash';\nimport { getUnreadConversationsCount, loadConversation, markAsUnreadApi } from '../../api/conversation-api';\nimport { connectFanpageApi, loadFanpages } from '../../api/fanpage';\nimport { loadStore } from '../storeState/storeAction';\nimport types from './fanpageTypes';\nexport function removeError() {\n  return {\n    type: types.REMOVE_ERROR_LOAD_FANPAGES\n  };\n}\nexport function setNewMessage(payload) {\n  return {\n    type: types.SET_NEW_MESSAGE,\n    payload\n  };\n}\nexport function removeConversations() {\n  return {\n    type: types.REMOVE_CONVERSATIONS\n  };\n}\nexport function connectFanpageSuccess(payload) {\n  return {\n    type: types.CONNECT_FANPAGE_SUCCESSS,\n    payload\n  };\n}\nexport function connectFanpageFailed() {\n  return {\n    type: types.CONNECT_FANPAGE_FAILED\n  };\n}\nexport const connectFanpageAction = data => async (dispatch, getState) => {\n  const {\n    auth,\n    store\n  } = getState();\n  const {\n    token\n  } = auth;\n\n  if (store.store) {\n    const storeId = store.store._id;\n\n    try {\n      const res = await connectFanpageApi({\n        payload: data,\n        storeId,\n        token: token.accessToken\n      });\n      dispatch(connectFanpageSuccess(res.data));\n      dispatch(loadFanpageAction());\n      localStorage.removeItem('shortLiveToken');\n    } catch (e) {\n      dispatch(connectFanpageFailed());\n    }\n  } else {\n    dispatch(connectFanpageFailed());\n  }\n};\nexport const isActivePage = page => {\n  return page.active;\n};\nexport const loadFanpageAction = () => async (dispatch, getState) => {\n  const {\n    auth,\n    store\n  } = getState();\n  const {\n    token\n  } = auth;\n\n  if (get(store, 'store._id')) {\n    const storeId = store.store._id;\n\n    try {\n      dispatch({\n        type: types.LOAD_FANPAGES\n      });\n      let res = await loadFanpages(store.store._id);\n      const getCountPages = [];\n      let activePages = [];\n      let inactivePages = [];\n\n      if (res.data && res.data.length > 0) {\n        res.data.forEach(item => {\n          if (isActivePage(item)) {\n            activePages.push(item);\n          } else {\n            inactivePages.push(item);\n          }\n        });\n        activePages.map(item => {\n          getCountPages.push(getUnreadConversationsCount({\n            token: token.accessToken,\n            storeId,\n            fbPageId: item.fbObjectId\n          }));\n        });\n        const response = await Promise.all(getCountPages);\n\n        if (response) {\n          activePages = activePages.map((item, index) => {\n            item.countUnread = response[index];\n            return item;\n          });\n        }\n      }\n\n      dispatch({\n        type: types.LOAD_FANPAGES_SUCCESS,\n        payload: {\n          data: activePages.concat(inactivePages),\n          activePage: store.store.activePage\n        }\n      });\n    } catch (error) {\n      dispatch({\n        type: types.LOAD_FANPAGES_FAILED\n      });\n    }\n  } else {\n    dispatch(loadStore());\n  }\n};\nexport const updateUnreadForConversation = data => async (dispatch, getState) => {\n  const {\n    auth,\n    store,\n    fanpage\n  } = getState();\n  const {\n    token\n  } = auth;\n  const storeId = store.store._id;\n  const {\n    conversation\n  } = fanpage;\n\n  if (conversation && data.fbObjectId === conversation.fbObjectId) {\n    await markAsUnreadApi({\n      storeId,\n      fbPageId: conversation.fbPageId,\n      token: token.accessToken,\n      conversationId: conversation.fbObjectId,\n      read: true\n    });\n    dispatch({\n      type: types.MARK_AS_UNREAD,\n      payload: {\n        conversation: data,\n        unread: false\n      }\n    });\n  }\n\n  dispatch(updateCountUnreadPage({\n    fbObjectId: data.fbPageId\n  }));\n};\nexport const updateCountUnreadPage = data => async (dispatch, getState) => {\n  const {\n    auth,\n    store\n  } = getState();\n  const {\n    token\n  } = auth;\n  const storeId = store.store._id;\n  debounced(data, token.accessToken, storeId, dispatch);\n};\nexport const debounced = debounce(async function (data, accessToken, storeId, dispatch) {\n  const count = await getUnreadConversationsCount({\n    token: accessToken,\n    storeId,\n    fbPageId: data.fbObjectId\n  });\n  dispatch({\n    type: types.UPDATE_COUNT_UNREAD_PAGE,\n    payload: { ...data,\n      count\n    }\n  });\n}, 1000, {\n  leading: false,\n  trailing: true\n});\nexport const loadConversations = (query, paramFbPageIds, pageSelected, url) => async (dispatch, getState) => {\n  dispatch({\n    type: types.LOADING_CONVERSATIONS\n  });\n\n  try {\n    const {\n      store,\n      auth,\n      fanpage\n    } = getState();\n    const storeId = store.store._id;\n    const token = auth.token.accessToken;\n    const fbPageIds = !paramFbPageIds ? Object.values(fanpage.pages).map(page => page.fbObjectId) : paramFbPageIds;\n    const responses = await loadConversation({\n      fbPageIds,\n      storeId,\n      token,\n      query,\n      url\n    });\n\n    if (pageSelected) {\n      const countUnread = await getUnreadConversationsCount({\n        token,\n        storeId,\n        fbPageId: fbPageIds[0]\n      });\n      pageSelected.countUnread = countUnread;\n    }\n\n    dispatch({\n      type: types.LOAD_CONVERSATIONS_SUCCESS,\n      payload: pageSelected ? {\n        conversations: responses,\n        pageSelected\n      } : {\n        conversations: responses\n      }\n    });\n  } catch (error) {\n    dispatch({\n      type: types.LOAD_CONVERSATIONS_FAILED\n    });\n  }\n};\nexport function selectConversation(conversation) {\n  return {\n    type: types.SELECT_CONVERSATION,\n    payload: conversation\n  };\n}\nexport function markAsUnread(data) {\n  return {\n    type: types.MARK_AS_UNREAD,\n    payload: data\n  };\n}\nexport function newConversation(data) {\n  return {\n    type: types.NEW_CONVERSATION,\n    payload: data\n  };\n}\nexport const updateConversation = data => (dispatch, getState) => {\n  data.isUpdateMessage = true;\n  dispatch({\n    type: types.UPDATE_CONVERSATION,\n    payload: data\n  });\n};\nexport function updateLabelConversations(data) {\n  return {\n    type: types.UPDATE_LABEL_CONVERSATION,\n    payload: data\n  };\n}\nexport function updateLikeCommentsConversation(data) {\n  return {\n    type: types.UPDATE_LIKED_COMMENTS_CONVERSATION,\n    payload: data\n  };\n}\nexport function updateHiddenCommentsConversation(data) {\n  return {\n    type: types.UPDATE_HIDDEN_COMMENTS_CONVERSATION,\n    payload: data\n  };\n}\nexport function toggleBlockUser(data) {\n  return {\n    type: types.UPDATE_BLOCK_CONVERSATION,\n    payload: data\n  };\n}\nexport function setNullForConversation() {\n  return {\n    type: types.SET_NULL_FOR_CONVERSATION\n  };\n}\nexport function removeConversation(data) {\n  return {\n    type: types.REMOVE_CONVERSATION,\n    payload: data\n  };\n}\nexport function updateMainCommentConversation(data) {\n  return {\n    type: types.UPDATE_MAIN_COMMENT_CONVERSATION,\n    payload: data\n  };\n}\nexport function setCurrentPage(page) {\n  return {\n    type: types.SET_CURRENT_PAGE,\n    payload: page\n  };\n}\nexport function setFilterConversation(selected) {\n  return {\n    type: types.SET_FILTER_CONVERSATION,\n    payload: selected\n  };\n}","map":{"version":3,"sources":["/Users/mac3/Desktop/workspace/FacebookClient/src/reducers/fanpageState/fanpageAction.ts"],"names":["debounce","get","getUnreadConversationsCount","loadConversation","markAsUnreadApi","connectFanpageApi","loadFanpages","loadStore","types","removeError","type","REMOVE_ERROR_LOAD_FANPAGES","setNewMessage","payload","SET_NEW_MESSAGE","removeConversations","REMOVE_CONVERSATIONS","connectFanpageSuccess","CONNECT_FANPAGE_SUCCESSS","connectFanpageFailed","CONNECT_FANPAGE_FAILED","connectFanpageAction","data","dispatch","getState","auth","store","token","storeId","_id","res","accessToken","loadFanpageAction","localStorage","removeItem","e","isActivePage","page","active","LOAD_FANPAGES","getCountPages","activePages","inactivePages","length","forEach","item","push","map","fbPageId","fbObjectId","response","Promise","all","index","countUnread","LOAD_FANPAGES_SUCCESS","concat","activePage","error","LOAD_FANPAGES_FAILED","updateUnreadForConversation","fanpage","conversation","conversationId","read","MARK_AS_UNREAD","unread","updateCountUnreadPage","debounced","count","UPDATE_COUNT_UNREAD_PAGE","leading","trailing","loadConversations","query","paramFbPageIds","pageSelected","url","LOADING_CONVERSATIONS","fbPageIds","Object","values","pages","responses","LOAD_CONVERSATIONS_SUCCESS","conversations","LOAD_CONVERSATIONS_FAILED","selectConversation","SELECT_CONVERSATION","markAsUnread","newConversation","NEW_CONVERSATION","updateConversation","isUpdateMessage","UPDATE_CONVERSATION","updateLabelConversations","UPDATE_LABEL_CONVERSATION","updateLikeCommentsConversation","UPDATE_LIKED_COMMENTS_CONVERSATION","updateHiddenCommentsConversation","UPDATE_HIDDEN_COMMENTS_CONVERSATION","toggleBlockUser","UPDATE_BLOCK_CONVERSATION","setNullForConversation","SET_NULL_FOR_CONVERSATION","removeConversation","REMOVE_CONVERSATION","updateMainCommentConversation","UPDATE_MAIN_COMMENT_CONVERSATION","setCurrentPage","SET_CURRENT_PAGE","setFilterConversation","selected","SET_FILTER_CONVERSATION"],"mappings":"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","sourcesContent":["import { debounce, get } from 'lodash';\nimport moment from 'moment';\nimport { Dispatch } from 'redux';\n\nimport {\n    getUnreadConversationsCount,\n    loadConversation,\n    markAsUnreadApi,\n} from '../../api/conversation-api';\nimport { connectFanpageApi, loadFanpages, Payload } from '../../api/fanpage';\nimport { loadStore } from '../storeState/storeAction';\nimport { IAction, IConversation, Page } from './fanpageReducer';\nimport types from './fanpageTypes';\n\ninterface IDataSocket {\n    conversation: IConversation;\n}\n\nexport function removeError() {\n    return {\n        type: types.REMOVE_ERROR_LOAD_FANPAGES,\n    };\n}\nexport function setNewMessage(payload: any) {\n    return {\n        type: types.SET_NEW_MESSAGE,\n        payload,\n    };\n}\n\nexport function removeConversations() {\n    return {\n        type: types.REMOVE_CONVERSATIONS,\n    };\n}\n\nexport function connectFanpageSuccess(payload: any) {\n    return {\n        type: types.CONNECT_FANPAGE_SUCCESSS,\n        payload,\n    };\n}\n\nexport function connectFanpageFailed() {\n    return {\n        type: types.CONNECT_FANPAGE_FAILED,\n    };\n}\n\nexport const connectFanpageAction = (data: Payload) => async (\n    dispatch: Dispatch<any>,\n    getState: () => any\n) => {\n    const { auth, store } = getState();\n    const { token } = auth;\n\n    if (store.store) {\n        const storeId = store.store._id;\n\n        try {\n            const res = await connectFanpageApi({\n                payload: data,\n                storeId,\n                token: token.accessToken,\n            });\n            dispatch(connectFanpageSuccess(res.data));\n\n            dispatch(loadFanpageAction());\n            localStorage.removeItem('shortLiveToken');\n        } catch (e) {\n            dispatch(connectFanpageFailed());\n        }\n    } else {\n        dispatch(connectFanpageFailed());\n    }\n};\n\nexport const isActivePage = (page: any) => {\n    return page.active;\n};\n\nexport const loadFanpageAction = () => async (dispatch: any, getState: any) => {\n    const { auth, store } = getState();\n    const { token } = auth;\n\n    if (get(store, 'store._id')) {\n        const storeId = store.store._id;\n        try {\n            dispatch({\n                type: types.LOAD_FANPAGES,\n            });\n\n            let res = await loadFanpages(store.store._id);\n\n            const getCountPages: Promise<any>[] = [];\n            let activePages: any[] = [];\n            let inactivePages: any[] = [];\n            if (res.data && res.data.length > 0) {\n                res.data.forEach((item: any) => {\n                    if (isActivePage(item)) {\n                        activePages.push(item);\n                    } else {\n                        inactivePages.push(item);\n                    }\n                });\n\n                activePages.map((item: any) => {\n                    getCountPages.push(\n                        getUnreadConversationsCount({\n                            token: token.accessToken,\n                            storeId,\n                            fbPageId: item.fbObjectId,\n                        })\n                    );\n                });\n\n                const response = await Promise.all(getCountPages);\n                if (response) {\n                    activePages = activePages.map((item: any, index: number) => {\n                        item.countUnread = response[index];\n                        return item;\n                    });\n                }\n            }\n\n            dispatch({\n                type: types.LOAD_FANPAGES_SUCCESS,\n                payload: {\n                    data: activePages.concat(inactivePages),\n                    activePage: store.store.activePage,\n                },\n            });\n        } catch (error) {\n            dispatch({ type: types.LOAD_FANPAGES_FAILED });\n        }\n    } else {\n        dispatch(loadStore());\n    }\n};\n\nexport const updateUnreadForConversation = (data: any) => async (dispatch: any, getState: any) => {\n    const { auth, store, fanpage } = getState();\n    const { token } = auth;\n    const storeId = store.store._id;\n    const { conversation } = fanpage;\n\n    if (conversation && data.fbObjectId === conversation.fbObjectId) {\n        await markAsUnreadApi({\n            storeId,\n            fbPageId: conversation.fbPageId,\n            token: token.accessToken,\n            conversationId: conversation.fbObjectId,\n            read: true,\n        });\n        dispatch({\n            type: types.MARK_AS_UNREAD,\n            payload: { conversation: data, unread: false },\n        });\n    }\n    dispatch(updateCountUnreadPage({ fbObjectId: data.fbPageId }));\n};\n\nexport const updateCountUnreadPage = (data: { fbObjectId: string }) => async (\n    dispatch: Dispatch,\n    getState: any\n) => {\n    const { auth, store } = getState();\n    const { token } = auth;\n    const storeId = store.store._id;\n\n    debounced(data, token.accessToken, storeId, dispatch);\n};\n\nexport const debounced = debounce(\n    async function (data: any, accessToken: string, storeId: string, dispatch: Dispatch) {\n        const count = await getUnreadConversationsCount({\n            token: accessToken,\n            storeId,\n            fbPageId: data.fbObjectId,\n        });\n        dispatch({\n            type: types.UPDATE_COUNT_UNREAD_PAGE,\n            payload: { ...data, count },\n        });\n    },\n    1000,\n    { leading: false, trailing: true }\n);\n\nexport const loadConversations = (\n    query?: string,\n    paramFbPageIds?: string[],\n    pageSelected?: any,\n    url?: string\n) => async (dispatch: any, getState: any) => {\n    dispatch({\n        type: types.LOADING_CONVERSATIONS,\n    });\n\n    try {\n        const { store, auth, fanpage } = getState();\n        const storeId = store.store._id;\n        const token = auth.token.accessToken;\n        const fbPageIds = !paramFbPageIds\n            ? Object.values(fanpage.pages).map((page: any) => page.fbObjectId)\n            : paramFbPageIds;\n\n        const responses = await loadConversation({\n            fbPageIds,\n            storeId,\n            token,\n            query,\n            url,\n        });\n\n        if (pageSelected) {\n            const countUnread = await getUnreadConversationsCount({\n                token,\n                storeId,\n                fbPageId: fbPageIds[0],\n            });\n            pageSelected.countUnread = countUnread;\n        }\n\n        dispatch({\n            type: types.LOAD_CONVERSATIONS_SUCCESS,\n            payload: pageSelected\n                ? { conversations: responses, pageSelected }\n                : { conversations: responses },\n        });\n    } catch (error) {\n        dispatch({\n            type: types.LOAD_CONVERSATIONS_FAILED,\n        });\n    }\n};\n\nexport function selectConversation(conversation: IConversation): IAction {\n    return {\n        type: types.SELECT_CONVERSATION,\n        payload: conversation,\n    };\n}\n\nexport function markAsUnread(data: { conversation: IConversation; unread: boolean }): IAction {\n    return {\n        type: types.MARK_AS_UNREAD,\n        payload: data,\n    };\n}\n\nexport function newConversation(data: any): IAction {\n    return {\n        type: types.NEW_CONVERSATION,\n        payload: data,\n    };\n}\n\nexport const updateConversation = (data: any) => (dispatch: any, getState: any) => {\n    data.isUpdateMessage = true;\n\n    dispatch({\n        type: types.UPDATE_CONVERSATION,\n        payload: data,\n    });\n};\n\nexport function updateLabelConversations(data: any): IAction {\n    return {\n        type: types.UPDATE_LABEL_CONVERSATION,\n        payload: data,\n    };\n}\n\nexport function updateLikeCommentsConversation(data: any): IAction {\n    return {\n        type: types.UPDATE_LIKED_COMMENTS_CONVERSATION,\n        payload: data,\n    };\n}\n\nexport function updateHiddenCommentsConversation(data: any): IAction {\n    return {\n        type: types.UPDATE_HIDDEN_COMMENTS_CONVERSATION,\n        payload: data,\n    };\n}\n\nexport function toggleBlockUser(data: any) {\n    return {\n        type: types.UPDATE_BLOCK_CONVERSATION,\n        payload: data,\n    };\n}\n\nexport function setNullForConversation() {\n    return {\n        type: types.SET_NULL_FOR_CONVERSATION,\n    };\n}\n\nexport function removeConversation(data: { conversationId: string }): IAction {\n    return {\n        type: types.REMOVE_CONVERSATION,\n        payload: data,\n    };\n}\n\nexport function updateMainCommentConversation(data: {\n    conversationId: string;\n    fbObjectId: string;\n    commentIds: string[];\n}): IAction {\n    return {\n        type: types.UPDATE_MAIN_COMMENT_CONVERSATION,\n        payload: data,\n    };\n}\n\nexport function setCurrentPage(page: Page): IAction {\n    return {\n        type: types.SET_CURRENT_PAGE,\n        payload: page,\n    };\n}\n\nexport function setFilterConversation(selected: string[]): IAction {\n    return {\n        type: types.SET_FILTER_CONVERSATION,\n        payload: selected,\n    };\n}\n"]},"metadata":{},"sourceType":"module"}