{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport _get from 'lodash/get';\nimport moment from 'moment';\nimport React, { useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport io from 'socket.io-client';\nimport { NOTIFICATION_SERVER_URI } from '../../../configs/vars';\nimport { updateConversation, updateUnreadForConversation } from '../../../reducers/fanpageState/fanpageAction';\nimport { useNotification } from '../../customer/notfication-context';\nimport { checkToken } from '../../../api/token';\nimport authApi from '../../../api/auth-api';\nimport store from '../../../store';\nimport authTypes from '../../../reducers/authState/authTypes';\nimport { usePageVisibility } from '../../../hooks/usePageVisibility';\nimport { ConversationType } from '../../../collections/facebook-conversation';\nimport logo from '../../../assets/logo-fb.png';\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst SocketHandle = () => {\n  _s();\n\n  const isActiveTabPage = usePageVisibility();\n  const {\n    play\n  } = useNotification();\n  const dispatch = useDispatch();\n\n  const selectAuth = state => {\n    return state.auth;\n  };\n\n  const auth = useSelector(selectAuth);\n\n  const accessToken = _get(auth, 'token.accessToken');\n\n  let [socket, setSocket] = useState(null);\n\n  const handelSetAccessToken = accessToken => {\n    socket = io(`${NOTIFICATION_SERVER_URI}/?token=${accessToken}`, {\n      path: '/socket',\n      transports: ['websocket', 'polling']\n    });\n    setSocket(socket);\n  };\n\n  const getAccessToken = async () => {\n    try {\n      const isValidAccessToken = checkToken(accessToken);\n\n      if (!isValidAccessToken) {\n        const refreshToken = _get('auth', 'token.refreshToken');\n\n        const isValidRefreshToken = checkToken(refreshToken);\n\n        if (!isValidRefreshToken) {\n          return new Error('Token expired');\n        }\n\n        const accessTokenNew = await authApi.refreshAccessToken(refreshToken);\n        store.dispatch({\n          type: authTypes.UPDATE_TOKEN,\n          payload: accessToken\n        });\n        return accessTokenNew;\n      }\n\n      return accessToken;\n    } catch (error) {\n      return error;\n    }\n  };\n\n  const pushNotification = (type, value, conversation) => {\n    if (!isActiveTabPage && localStorage.getItem('isAllowPushNotify') === 'true') {\n      if (Notification.permission === 'granted') {\n        let notification;\n        const data = {\n          icon: logo,\n          body: `${value.name}: ${value.text}`\n        };\n\n        switch (type) {\n          case ConversationType.Comment:\n            notification = new Notification('Bình luận mới', data);\n\n            notification.onclick = function () {\n              window.open(`${window.location.origin}/customer/conversation?pageId=${conversation.fbPageId}&postId=${conversation.postId}&type=${ConversationType.Comment}`);\n            };\n\n            break;\n\n          case ConversationType.Message:\n            notification = new Notification('Tin nhắn mới', data);\n\n            notification.onclick = function () {\n              window.open(`${window.location.origin}/customer/conversation?pageId=${conversation.fbPageId}&type=${ConversationType.Message}`);\n            };\n\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n  };\n\n  useEffect(() => {\n    if (accessToken) {\n      if (socket) {\n        socket.close();\n      }\n\n      getAccessToken().then(async accessToken => {\n        await handelSetAccessToken(accessToken);\n      });\n    }\n\n    return () => socket && socket.close();\n  }, [accessToken]);\n  useEffect(() => {\n    if (socket) {\n      socket.on('comment', res => {\n        const {\n          changes,\n          conversation\n        } = res.entry[0];\n\n        if (conversation && changes) {\n          const {\n            value\n          } = changes[0];\n          const newCommentPush = {\n            name: _get(value, 'from.name'),\n            text: value.message\n          };\n          const newMessage = {\n            type: 2,\n            id: value.comment_id,\n            message: value.message,\n            from: value.from\n          };\n\n          if (value.item === 'comment' && value.photo) {\n            newMessage.attachment = {\n              type: 'photo',\n              media: {\n                image: {\n                  src: value.photo\n                }\n              }\n            };\n\n            if (!newCommentPush.text) {\n              newCommentPush.text = 'đã gửi một ảnh';\n            }\n          }\n\n          pushNotification(ConversationType.Comment, newCommentPush, conversation);\n          dispatch(updateConversation({\n            conversation: { ...conversation,\n              message: value.message\n            },\n            newMessage\n          }));\n          dispatch(updateUnreadForConversation(conversation)); // play sound\n\n          if (conversation.unread) {\n            play();\n          }\n        }\n      });\n      socket.on('message', res => {\n        const {\n          conversation,\n          messaging\n        } = res.entry[0];\n        const message = messaging[0].message;\n        const newMessagePush = {\n          name: conversation.fbUsername,\n          text: message.text\n        };\n        let countVideo = 0;\n        let countImage = 0;\n        const data = message.attachments && message.attachments.map(a => {\n          if (a.type === 'video') {\n            countVideo++;\n            return {\n              id: Date.now(),\n              video_data: {\n                url: a.payload.url\n              },\n              mime_type: 'video/mp4'\n            };\n          }\n\n          countImage++;\n          return {\n            id: Date.now(),\n            image_data: {\n              preview_url: a.payload.url,\n              url: a.payload.url\n            },\n            mime_type: 'image/jpeg'\n          };\n        });\n\n        if (!newMessagePush.text) {\n          if (countVideo > 0 && countImage > 0) {\n            newMessagePush.text = `đã gửi ${countVideo} file âm thanh và ${countImage} ảnh`;\n          } else if (countImage > 0) {\n            newMessagePush.text = `đã gửi ${countImage} ảnh`;\n          } else if (countVideo > 0) {\n            newMessagePush.text = `đã gửi ${countVideo} file âm thanh`;\n          }\n        }\n\n        const newMessage = {\n          type: 1,\n          create_time: moment(new Date()).format(),\n          id: message.mid,\n          message: message.text || '',\n          attachments: {\n            data\n          },\n          from: {\n            id: messaging[0].sender.id\n          }\n        };\n        pushNotification(ConversationType.Message, newMessagePush, conversation);\n        dispatch(updateConversation({\n          conversation: { ...conversation,\n            message: message.text\n          },\n          newMessage\n        }));\n        dispatch(updateUnreadForConversation(conversation)); // play sound\n\n        if (conversation.unread) {\n          play();\n        }\n      });\n      socket.on('error', res => {// action error\n      });\n    }\n\n    localStorage.setItem('isAllowPushNotify', isActiveTabPage ? 'false' : 'true');\n\n    if (isActiveTabPage) {\n      window.localStorage.setItem('isOneActiveTab', 'true');\n    }\n  }, [socket, isActiveTabPage]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false);\n};\n\n_s(SocketHandle, \"X4qQobnP6rRWa4hCHzYzGfh6B/4=\", false, function () {\n  return [usePageVisibility, useNotification, useDispatch, useSelector];\n});\n\n_c = SocketHandle;\nSocketHandle.propTypes = {};\nexport default SocketHandle;\n\nvar _c;\n\n$RefreshReg$(_c, \"SocketHandle\");","map":{"version":3,"sources":["/Users/mac3/Desktop/workspace/FacebookClient/src/pages/conversation/socket-handle/index.tsx"],"names":["_get","moment","React","useEffect","useState","useDispatch","useSelector","io","NOTIFICATION_SERVER_URI","updateConversation","updateUnreadForConversation","useNotification","checkToken","authApi","store","authTypes","usePageVisibility","ConversationType","logo","SocketHandle","isActiveTabPage","play","dispatch","selectAuth","state","auth","accessToken","socket","setSocket","handelSetAccessToken","path","transports","getAccessToken","isValidAccessToken","refreshToken","isValidRefreshToken","Error","accessTokenNew","refreshAccessToken","type","UPDATE_TOKEN","payload","error","pushNotification","value","conversation","localStorage","getItem","Notification","permission","notification","data","icon","body","name","text","Comment","onclick","window","open","location","origin","fbPageId","postId","Message","close","then","on","res","changes","entry","newCommentPush","message","newMessage","id","comment_id","from","item","photo","attachment","media","image","src","unread","messaging","newMessagePush","fbUsername","countVideo","countImage","attachments","map","a","Date","now","video_data","url","mime_type","image_data","preview_url","create_time","format","mid","sender","setItem","propTypes"],"mappings":"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","sourcesContent":["import _get from 'lodash/get';\nimport moment from 'moment';\nimport React, { FC, useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport io from 'socket.io-client';\n\nimport { NOTIFICATION_SERVER_URI } from '../../../configs/vars';\nimport { IAuthState } from '../../../reducers/authState/authReducer';\nimport {\n    updateConversation,\n    updateCountUnreadPage,\n    updateUnreadForConversation,\n} from '../../../reducers/fanpageState/fanpageAction';\nimport { IFacebookState } from '../../../reducers/fanpageState/fanpageReducer';\nimport { useNotification } from '../../customer/notfication-context';\nimport { checkToken } from '../../../api/token';\nimport authApi from '../../../api/auth-api';\nimport store from '../../../store';\nimport authTypes from '../../../reducers/authState/authTypes';\nimport { usePageVisibility } from '../../../hooks/usePageVisibility';\nimport { ConversationType } from '../../../collections/facebook-conversation';\nimport logo from '../../../assets/logo-fb.png';\n\ninterface State {\n    auth: IAuthState;\n    fanpage: IFacebookState;\n}\n\ninterface IMessage {\n    mid: string;\n    text: string;\n}\n\nconst SocketHandle: FC = (): JSX.Element => {\n    const isActiveTabPage = usePageVisibility();\n    const { play } = useNotification();\n    const dispatch = useDispatch();\n\n    const selectAuth = (state: State) => {\n        return state.auth;\n    };\n\n    const auth = useSelector(selectAuth);\n\n    const accessToken: string = _get(auth, 'token.accessToken');\n\n    let [socket, setSocket] = useState<any>(null);\n\n    const handelSetAccessToken = (accessToken: string) => {\n        socket = io(`${NOTIFICATION_SERVER_URI}/?token=${accessToken}`, {\n            path: '/socket',\n            transports: ['websocket', 'polling'],\n        });\n        setSocket(socket);\n    };\n\n    const getAccessToken = async () => {\n        try {\n            const isValidAccessToken = checkToken(accessToken);\n            if (!isValidAccessToken) {\n                const refreshToken = _get('auth', 'token.refreshToken');\n                const isValidRefreshToken = checkToken(refreshToken);\n                if (!isValidRefreshToken) {\n                    return new Error('Token expired');\n                }\n                const accessTokenNew = await authApi.refreshAccessToken(refreshToken);\n                store.dispatch({\n                    type: authTypes.UPDATE_TOKEN,\n                    payload: accessToken,\n                });\n                return accessTokenNew;\n            }\n            return accessToken;\n        } catch (error) {\n            return error;\n        }\n    };\n    \n    const pushNotification = (type: ConversationType, value: { name: string, text: string }, conversation: any) => {\n        if (!isActiveTabPage && localStorage.getItem('isAllowPushNotify') === 'true') {\n            if (Notification.permission === 'granted') {\n                let notification;\n\n                const data = {\n                    icon: logo,\n                    body: `${value.name}: ${value.text}`,\n                };\n\n                switch (type) {\n                    case ConversationType.Comment:\n                        notification = new Notification('Bình luận mới', data);\n                        notification.onclick = function() {\n                            window.open(`${window.location.origin}/customer/conversation?pageId=${conversation.fbPageId}&postId=${conversation.postId}&type=${ConversationType.Comment}`);\n                        };\n                        break;\n                \n                    case ConversationType.Message:\n                        notification = new Notification('Tin nhắn mới', data);\n                        notification.onclick = function() {\n                            window.open(`${window.location.origin}/customer/conversation?pageId=${conversation.fbPageId}&type=${ConversationType.Message}`);\n                        };\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    };\n\n    useEffect(() => {\n        if (accessToken) {\n            if (socket) {\n                socket.close();\n            }\n            getAccessToken().then(async (accessToken) => {\n                await handelSetAccessToken(accessToken);\n            });\n        }\n\n        return () => socket && socket.close();\n    }, [accessToken]);\n\n    useEffect(() => {\n        if (socket) {\n            socket.on('comment', (res: any) => {\n                const { changes, conversation } = res.entry[0];\n                if (conversation && changes) {\n                    const { value } = changes[0];\n\n                    const newCommentPush = {\n                        name: _get(value, 'from.name'),\n                        text: value.message,\n                    };\n\n                    const newMessage: any = {\n                        type: 2,\n                        id: value.comment_id,\n                        message: value.message,\n                        from: value.from,\n                    };\n\n                    if (value.item === 'comment' && value.photo) {\n                        newMessage.attachment = {\n                            type: 'photo',\n                            media: {\n                                image: {\n                                    src: value.photo,\n                                },\n                            },\n                        };\n\n                        if (!newCommentPush.text) {\n                            newCommentPush.text = 'đã gửi một ảnh';\n                        }\n                    }\n\n                    pushNotification(ConversationType.Comment, newCommentPush, conversation);\n\n                    dispatch(\n                        updateConversation({\n                            conversation: {\n                                ...conversation,\n                                message: value.message,\n                            },\n                            newMessage,\n                        }),\n                    );\n\n                    dispatch(updateUnreadForConversation(conversation));\n\n                    // play sound\n                    if (conversation.unread) {\n                        play();\n                    }\n                }\n            });\n\n            socket.on('message', (res: any) => {\n                const { conversation, messaging } = res.entry[0];\n                const message: any = messaging[0].message;\n\n                const newMessagePush = {\n                    name: conversation.fbUsername,\n                    text: message.text,\n                };\n                let countVideo = 0;\n                let countImage = 0;\n\n                const data =\n                    message.attachments &&\n                    message.attachments.map((a: any) => {\n                        if (a.type === 'video') {\n                            countVideo++;\n                            return {\n                                id: Date.now(),\n                                video_data: {\n                                    url: a.payload.url,\n                                },\n                                mime_type: 'video/mp4',\n                            };\n                        }\n\n                        countImage++;\n                        return {\n                            id: Date.now(),\n                            image_data: {\n                                preview_url: a.payload.url,\n                                url: a.payload.url,\n                            },\n                            mime_type: 'image/jpeg',\n                        };\n                    });\n\n                if (!newMessagePush.text) {\n                    if (countVideo > 0 && countImage > 0) {\n                        newMessagePush.text = `đã gửi ${countVideo} file âm thanh và ${countImage} ảnh`;\n                    } else if (countImage > 0) {\n                        newMessagePush.text = `đã gửi ${countImage} ảnh`;\n                    } else if (countVideo > 0) {\n                        newMessagePush.text = `đã gửi ${countVideo} file âm thanh`;\n                    }\n                }\n\n                const newMessage = {\n                    type: 1,\n                    create_time: moment(new Date()).format(),\n                    id: message.mid,\n                    message: message.text || '',\n                    attachments: { data },\n                    from: { id: messaging[0].sender.id },\n                };\n\n                pushNotification(ConversationType.Message, newMessagePush, conversation);\n\n                dispatch(\n                    updateConversation({\n                        conversation: {\n                            ...conversation,\n                            message: message.text,\n                        },\n                        newMessage,\n                    }),\n                );\n\n                dispatch(updateUnreadForConversation(conversation));\n\n                // play sound\n                if (conversation.unread) {\n                    play();\n                }\n            });\n    \n            socket.on('error', (res: any) => {\n                // action error\n            });\n        }\n\n        localStorage.setItem('isAllowPushNotify', isActiveTabPage ? 'false' : 'true');\n        if (isActiveTabPage) {\n            window.localStorage.setItem('isOneActiveTab', 'true');\n        }\n    }, [socket, isActiveTabPage]);\n\n    return <></>;\n};\n\nSocketHandle.propTypes = {};\n\nexport default SocketHandle;\n"]},"metadata":{},"sourceType":"module"}